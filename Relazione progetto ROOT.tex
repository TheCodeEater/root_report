\documentclass[12pt, a4paper]{article}
\title{Relazione progetto ROOT} %argomento
\date{}
\author{Stella Baldrati, Giacomo Errani, Riccardo Giuliani}

\setlength{\parindent}{0pt}
\usepackage{setspace}
\usepackage[margin=0.5in]{geometry}
\usepackage{float}
\usepackage{amsfonts}
\usepackage{pdfpages}
\usepackage{verbatim}
\usepackage[utf8]{inputenc}
\usepackage{subcaption}
\usepackage{graphicx}

%\usepackage{siunitx} 
%\sisetup{
  %round-mode          = places, % Rounds numbers
 % round-precision     = 2, % to 2 places
%}

\graphicspath{ {./images} } %cartella immagini, separata dalla cartella files

\usepackage{listings}
\usepackage{xcolor}


\begin{document}

\maketitle

\section{Introduzione}
%%inserire un po' di teoria alla base e sintetizzare tutto il contenuto come in un abstract

Nella fisica delle particelle, il tipico approccio sperimentale per studiarne proprietà e interazioni si basa sullo studio di collisioni tra esse ad alta velocità. A seguito degli urti, si generano molte particelle (stimate in $10^2-10^4$ per ogni evento di collisione) di vari tipi. 
\newline
Le più stabili sono rilevabili e classificabili direttamente analizzandone la traiettoria, ma vi sono anche risonanze (particelle instabili) che decadono in brevissimo tempo e non sono rilevabili direttamente, ma solo mediante i prodotti dei loro decadimenti, che sono generalmente particelle sufficientemente stabili.
\newline
Il programma qui illustrato simula eventi di collisione generandone i prodotti, simili a quelli ottenibili tramite un acceleratore, analizza le particelle generate ed elabora i decadimenti, esponendone le quantità e distribuzioni tramite grafici ROOT. 

In particolare, consente di studiare il comportamento della risonanza K*, cercandone il picco caratteristico di massa invariante dovuto ai prodotti del suo decadimento nel segnale di fondo.

\section{Struttura del codice}
%quali classi sono state implementate, con che funzione,
%quali meccanismi di reimpiego di codice sono stati usati, e perchè

\subsection{Programma di generazione}

Sono state implementate le seguenti classi:

\begin{enumerate}
\item ParticleType: rappresenta una generica particella stabile mediante massa, carica e tipologia, fornisce un'interfaccia per accedere a questi dati. Implementa inoltre una funzione \verb!GetWidth! che fornisce una larghezza di risonanza nulla ed è necessaria per poter utilizzare il polimorfismo dinamico. 
Definisce un enum che identifica i tipi di particelle utilizzabili, poi associati alle istanze di ParticleType.

\item ResonanceType: classe derivata di ParticleType, rappresenta il fenomeno di risonanza per una particella instabile con l'attributo larghezza di risonanza e reimplementa \verb!GetWidth! per restituire il valore corretto. 

\item Particle: rappresenta una particella della simulazione, mediante il tipo e la quantità di moto. 
Fornisce dei metodi per accedere agli attributi della particella, per calcolare la massa invariante ed elaborare un decadimento (funzione \verb!Decay2Body!).
Definisce un vettore statico (\verb!fParticleTypes!) che memorizza i tipi di particelle, associati alle singole istanze mediante l'attributo \verb!fParticleName!.

\item ProportionGenerator: class template che implementa il generatore secondo definite proporzioni. 
\item ParticleGenerator: oggetto funzione che incapsula la generazione delle particelle. 
Fornisce un \verb!operator()! per eseguire la generazione e una funzione \verb!loadParticles()! per caricare i parametri dei tipi di particelle nel vettore \verb!fParticleTypes!.

\item ParticleStorage: struct serializzabile che memorizza i vari istogrammi. 

\end{enumerate}

\subsection{Programma di analisi}

\begin{enumerate}
\item ParticleAnalyser: incapsula la lettura del file root (con controllo integrità dei dati mediante un cast dinamico) nel costruttore. Fornisce un metodo \verb!GetData! per accedere ai dati, una funzione di analisi dei segnali dei decadimenti (\verb!GetDecaymentSignal!) e una di analisi delle distribuzione di generazione (\verb!GetGenerationFits!). 

\item AnalyserGraphics: incapsula la presentazione dei dati, crea i canvas, configura lo stile, disegna istogrammi e fit.


\end{enumerate}

\subsection{Tecniche di reimpiego del codice}
%note su cosa scrivere: tecniche oop, incapsulamento, uso della classe proportion generator, implementare la funzionalità comune in classi e usando funzioni generiche, nascondendo i dettagli implementativi
Abbiamo usato le tecniche della programmazione OOP per separare dettagli implementativi e interfaccia, incapsulando le funzioni e rendendo il tutto modulare.
\newline

In particolare, la classe \verb!ProportionGenerator! si adatta a generare qualsiasi tipo di oggetto, note le istanze generabili e le probabilità.
\newline

Infine, l'uso del polimorfismo dinamico nelle classi \verb!ParticleType! e \verb!ResonanceType! consente di gestire le particelle stabili e instabili con puntatori di tipo \verb!ParticleType!, trattandole come se fossero dello stesso tipo.

\section{Generazione}
% specifichiamo che si tratta di eventi separati e non tutte insieme

Sono stati elaborati 10$^5$, in ciascuno dei quali sono state generate 10$^2$ particelle, secondo definite proporzioni, di tipo pione($\pi$), kaone(K), protone(P) e kaone instabile(K*):

\begin{itemize}

\item Tutti i tipi di particelle si presentano nella doppia forma positiva (+) e negativa (-). 

\item La composizione del campione è stata così generata: 40\% pioni positivi, 40\% pioni negativi, 5\% kaoni positivi, 5\% kaoni negativi, 4.5\% protoni positivi, 4.5\% protoni negativi, e 1\% kaoni instabili.

\item Le proprietà cinematiche delle particelle (angolo polare, angolo azimutale, modulo della quantità di moto) sono state generate tramite la generazione Monte Carlo di ROOT, utilizzando le funzioni \verb!TRandom::Rndm()!, 
\verb!TRandom::Uniform()!,\verb!TRandom::Exp(double mean)!.

\end{itemize}

\subsection{Elaborazione dei decadimenti}
In ogni evento si generano 1-2 K*, il cui decadimento è elaborato in fase di generazione.
Da una K* si possono ottenere o una coppia Pione+/Kaone- o Pione-/Kaone+, ciascuna con probabilità del 50\%.


\section{Analisi}
%Discutere la congruenza delle distribuzioni osservate con i dati in input
%alla generazione, spiegare brevemente l’approccio seguito per estrarre il segnale
%della risonanza
Riportiamo le tabelle delle occorrenze dei tipi di particelle, distribuzione di generazione dei parametri cinematici e segnale della K*.

\begin{table}[H]
  \begin{center}
    \caption{Abbondanza delle particelle.}
    \label{tab:table1}
    \begin{tabular}{c|c|c} % 
      \textbf{Specie} & 
      \textbf{Occorrenze osservate ($10^3$)} & 
      \textbf{occorrenze attese ($10^3$)}\\
      
      \hline
      $\pi$+ & 4000 $\pm$ 2 & 4000\\
      $\pi$- & 4000 $\pm$ 2 & 4000\\
      K+ 	 & 500.0 $\pm$ 0.7 & 500\\
      K- 	 & 500.0 $\pm$ 0.7 & 500\\
      P+ 	 & 450.0 $\pm$ 0.7  & 450\\
      P- 	 & 450.0 $\pm$ 0.7 & 450\\
      K* 	 & 100.0 $\pm$ 0.3 & 100\\
     

    \end{tabular}
  \end{center}
\end{table}

\begin{table}[H]
  \begin{center}
    \caption{Distribuzione angoli polari e azimutali, modulo dell'impulso.}
    \label{tab:table2}
    \begin{tabular}{c|c|c|c|c} % 
      \textbf{Distribuzione} & \textbf{parametri del fit} & \textbf{$\chi$} & \textbf{DOF} & \textbf{$\chi$/DOF}\\
      \hline
      Angolo polare & 0.3183 $\pm$ 0.0001 & 102.69 & 99 & 1.04\\
      Angolo azimutale & 0.1592 $\pm$ 0.0001 & 92.88 & 99 & 0.94 \\
      Impulso & -1.0003 $\pm$ 0.0003 & 125.42 & 98 & 1.28\\
    \end{tabular}
  \end{center}
\end{table}

I valori osservati nelle tabelle \ref{tab:table1} e \ref{tab:table2} sono compatibili con i parametri del generatore di particelle.
I valori di angolo polare e azimutale sono stati adattati ad una distribuzione normalizzata, al contrario di quella prodotta dal programma di generazione.

\begin{table}[H]
  \begin{center}
    \caption{Analisi della K*.}
    \label{tab:table3}
    \begin{tabular}{c|c|c|c|c} % 
      \textbf{Distribuzione e fit} & 
      \textbf{Media ($\frac{GeV}{c^2}$)} & 
      \textbf{$\sigma$ ($\frac{GeV}{c^2}$)} & 
      \textbf{Ampiezza ($10^4$)} & 
      \textbf{$\chi^2$/DOF}\\
      
      \hline
      Coppie $\pi$/K  & 0.886 $\pm$ 0.003 &0.051 $\pm$ 0.003  & 8.0 $\pm$ 0.4 & 1.03\\
      Discordi-Concordi & 0.892 $\pm$ 0.004 & 0.042 $\pm$ 0.004 & 9.0 $\pm$ 0.7 & 0.99\\
      Benchmark & 0.8918 $\pm$ 0.0002 & 0.0500 $\pm$ 0.0001 & 8.00 $\pm$ 0.03  &  1.23\\
    \end{tabular}
  \end{center}
\end{table}

\subsection{Estrazione del segnale di risonanza}
Per estrarre il segnale di risonanza, abbiamo sfruttato il fatto che il decadimento della K* introduce delle particelle in coppie Pione-Kaone con carica discorde. 

Ci aspettiamo che queste contribuiscano agli istogrammi di massa invariante di \textit{carica discorde} e \textit{coppie Pione-Kaone discordi}.

Al contrario, nei rispettivi istogrammi di carica concorde, ci aspettiamo di osservare solo fondo.

Sottraendo rispettivamente gli istogrammi, i segnali di fondo si elidono e resta il segnale della K*.
Un fit gaussiano consente di estrarre la distribuzione di massa invariante caratteristica della K* e determinarne massa (media della gaussiana) e larghezza di risonanza (deviazione standard).

\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{images/DistributionsCanvas.png}

\label{fig:fig1}
\caption{Distribuzioni di angolo polare, angolo azimutale, modulo dell'impulso e tipo di particella}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{images/SignalCanvas.png}

\label{fig:fig2}
\caption{Distribuzione delle masse invarianti.}
\end{figure}

In figura \ref{fig:fig2} sono riportate le distribuzioni di massa invariante. A sinistra, ottenute per sottrazione degli istogrammi di massa invariante Pioni-Kaoni \textit{discorde-concorde}. Al centro, ottenuti per sottrazione degli istogrammi di massa invariante tra tutte le particelle di carica \textit{discorde-concorde}. A destra, le masse invarianti ottenute a partire dalle particelle figlie di una stessa K*.

\subsection{Consistenza delle distribuzioni}
Le distribuzioni dei parametri cinematici e del tipo di particella (figura \ref{fig:fig1}) sono consistenti con le impostazioni del generatore.


\section{Appendice}

Riportiamo il codice del programma.

\subsection{Programma di generazione}

\paragraph{main.cpp}

\begin{verbatim}
#include "Definitions.hpp"

#include "TApplication.h"
#include "TDirectory.h"
#include <TH1.h>
#include "TFile.h"

#include "generator/ParticleGenerator.hpp"
#include "particleStorage.hpp"
#include "particles/ParticleType.hpp"

int main(int argc, char **argv) {
    // object ownership setup
    #ifdef PROGRAM_USE_LOCAL_OWNERSHIP
        TDirectory::AddDirectory(kFALSE);
        TH1::AddDirectory(kFALSE);
    #endif

    //allocate memory for particle data
    ResonanceSimulator::particleGenerator::loadParticles();

    //create generator object
    ResonanceSimulator::particleGenerator generator{};
    // run the simulation
    // save result in unique pointer
    std::unique_ptr<ResonanceSimulator::particleStorage> result{generator(1e5)};

    //write to file
    std::unique_ptr<TFile> output_file{new TFile("Particle.root", "RECREATE")};
    result->Write();
    output_file->Close();

    return 0;
}
\end{verbatim}

\paragraph{ProportionGenerator.hpp}
Questa classe è un template, quindi interamente definita nell'header.

\begin{verbatim}
#ifndef PROPORTIONGENERATOR_HPP
#define PROPORTIONGENERATOR_HPP

#include "particles/ParticleType.hpp"
#include <map>
#include <vector>
#include <iostream>
#include <numeric>

#include "TRandom.h"

namespace ResonanceSimulator {

/**
 * This class generates, based on definite proportions, the elements it is instructed to
 * @tparam GEN The type of the object to be generated
 *
 * NOTE: probability is given in percentile in integer values (to avoid FP problems)
 */
    template<typename GEN>
    class proportionGenerator {
        /**
         * Struct representing a node of generation, holding values with cumulative weight
         */
        struct node {
            GEN fValue{}; /// Value
            float fCumulativeProbability{}; /// Relevant cumulative probability
        };
        /**
         * Construct the generator
         * @param sourceData Map associating values to be generated to relevant probability values
         */
    public:
        using probType = float;/// type to represent probability

        explicit proportionGenerator(std::map<GEN, probType> sourceData) :
                fNodes{} {
            //check probability
            auto totalProb = std::accumulate(sourceData.begin(),
                                             sourceData.end(),
                                             0, [](auto const &acc, auto const &node) {
                        return acc + node.second; //sum probabilities
                    });

            if (std::abs(totalProb - 100) < 0.01) { //FP epsilon
                throw std::runtime_error{"Sum of probability is not 100!"};
            }

            //allocate space for the nodes
            fNodes.reserve(sourceData.size());
            //fill f nodes
            probType accumulator{0}; //hold accumulate probability
            for (auto const &node: sourceData) {
                accumulator += node.second; //accumulate probabilities
                fNodes.push_back({node.first, accumulator});
            }
        }

        /**
         * Generate function
         * @return A randomly generated value, based on the input data
         */
        GEN operator()() {
            //genrate value, cast to int
            probType y{static_cast<probType>(gRandom->Rndm())};

            for (auto const &node: fNodes) {
                //if the value generated is less than, i am generated
                if (y < node.fCumulativeProbability) {
                    return node.fValue; //end cycle
                }
            }
            throw std::runtime_error{"Cannot generate!"};
        }

    private:
        std::vector<node> fNodes;


    };

}

#endif 

\end{verbatim}

\paragraph{•}



\end{document}