\documentclass[12pt, a4paper]{article}
\title{Relazione progetto ROOT} %argomento
\date{}
\author{Stella Baldrati, Giacomo Errani, Riccardo Giuliani}

\setlength{\parindent}{0pt}
\usepackage{setspace}
\usepackage[margin=0.5in]{geometry}
\usepackage{float}
\usepackage{amsfonts}
\usepackage{pdfpages}
\usepackage{verbatim}
\usepackage[utf8]{inputenc}
\usepackage{subcaption}
\usepackage{graphicx}

%\usepackage{siunitx} 
%\sisetup{
  %round-mode          = places, % Rounds numbers
 % round-precision     = 2, % to 2 places
%}

\graphicspath{ {./images} } %cartella immagini, separata dalla cartella files

\usepackage{listings}
\usepackage{xcolor}


\begin{document}

\maketitle

\section{Introduzione}
%%inserire un po' di teoria alla base e sintetizzare tutto il contenuto come in un abstract

Nella fisica delle particelle, il tipico approccio sperimentale per studiarne proprietà e interazioni si basa sullo studio di collisioni tra esse ad alta velocità. A seguito degli urti, si generano molte particelle (stimate in $10^2-10^4$ per ogni evento di collisione) di vari tipi. 
\newline
Le più stabili sono rilevabili e classificabili direttamente analizzandone la traiettoria, ma vi sono anche risonanze (particelle instabili) che decadono in brevissimo tempo e non sono rilevabili direttamente, ma solo mediante i prodotti dei loro decadimenti, che sono generalmente particelle sufficientemente stabili.
\newline
Il programma qui illustrato simula eventi di collisione generandone i prodotti, simili a quelli ottenibili tramite un acceleratore, analizza le particelle generate ed elabora i decadimenti, esponendone le quantità e distribuzioni tramite grafici ROOT. 

In particolare, consente di studiare il comportamento della risonanza K*, cercandone il picco caratteristico di massa invariante dovuto ai prodotti del suo decadimento nel segnale di fondo.

\section{Struttura del codice}
%quali classi sono state implementate, con che funzione,
%quali meccanismi di reimpiego di codice sono stati usati, e perchè

\subsection{Programma di generazione}

Sono state implementate le seguenti classi:

\begin{enumerate}
\item ParticleType: rappresenta una generica particella stabile mediante massa, carica e tipologia, fornisce un'interfaccia per accedere a questi dati. Implementa inoltre una funzione \verb!GetWidth! che fornisce una larghezza di risonanza nulla ed è necessaria per poter utilizzare il polimorfismo dinamico. 
Definisce un enum che identifica i tipi di particelle utilizzabili, poi associati alle istanze di ParticleType.

\item ResonanceType: classe derivata di ParticleType, rappresenta il fenomeno di risonanza per una particella instabile con l'attributo larghezza di risonanza e reimplementa \verb!GetWidth! per restituire il valore corretto. 

\item Particle: rappresenta una particella della simulazione, mediante il tipo e la quantità di moto. 
Fornisce dei metodi per accedere agli attributi della particella, per calcolare la massa invariante ed elaborare un decadimento (funzione \verb!Decay2Body!).
Definisce un vettore statico (\verb!fParticleTypes!) che memorizza i tipi di particelle, associati alle singole istanze mediante l'attributo \verb!fParticleName!.

\item ProportionGenerator: class template che implementa il generatore secondo definite proporzioni. 
\item ParticleGenerator: oggetto funzione che incapsula la generazione delle particelle. 
Fornisce un \verb!operator()! per eseguire la generazione e una funzione \verb!loadParticles()! per caricare i parametri dei tipi di particelle nel vettore \verb!fParticleTypes!.

\item ParticleStorage: struct serializzabile che memorizza i vari istogrammi. 

\end{enumerate}

\subsection{Programma di analisi}

\begin{enumerate}
\item ParticleAnalyser: incapsula la lettura del file root (con controllo integrità dei dati mediante un cast dinamico) nel costruttore. Fornisce un metodo \verb!GetData! per accedere ai dati, una funzione di analisi dei segnali dei decadimenti (\verb!GetDecaymentSignal!) e una di analisi delle distribuzione di generazione (\verb!GetGenerationFits!). 

\item AnalyserGraphics: incapsula la presentazione dei dati, crea i canvas, configura lo stile, disegna istogrammi e fit.


\end{enumerate}

\subsection{Tecniche di reimpiego del codice}
%note su cosa scrivere: tecniche oop, incapsulamento, uso della classe proportion generator, implementare la funzionalità comune in classi e usando funzioni generiche, nascondendo i dettagli implementativi
Abbiamo usato le tecniche della programmazione OOP per separare dettagli implementativi e interfaccia, incapsulando le funzioni e rendendo il tutto modulare.
\newline

In particolare, la classe \verb!ProportionGenerator! si adatta a generare qualsiasi tipo di oggetto, note le istanze generabili e le probabilità.
\newline

Infine, l'uso del polimorfismo dinamico nelle classi \verb!ParticleType! e \verb!ResonanceType! consente di gestire le particelle stabili e instabili con puntatori di tipo \verb!ParticleType!, trattandole come se fossero dello stesso tipo.

\section{Generazione}
% specifichiamo che si tratta di eventi separati e non tutte insieme

Sono stati elaborati 10$^5$, in ciascuno dei quali sono state generate 10$^2$ particelle, secondo definite proporzioni, di tipo pione($\pi$), kaone(K), protone(P) e kaone instabile(K*):

\begin{itemize}

\item Tutti i tipi di particelle si presentano nella doppia forma positiva (+) e negativa (-). 

\item La composizione del campione è stata così generata: 40\% pioni positivi, 40\% pioni negativi, 5\% kaoni positivi, 5\% kaoni negativi, 4.5\% protoni positivi, 4.5\% protoni negativi, e 1\% kaoni instabili.

\item Le proprietà cinematiche delle particelle (angolo polare, angolo azimutale, modulo della quantità di moto) sono state generate tramite la generazione Monte Carlo di ROOT, utilizzando le funzioni \verb!TRandom::Rndm()!, 
\verb!TRandom::Uniform()!,\verb!TRandom::Exp(double mean)!.

\end{itemize}

\subsection{Elaborazione dei decadimenti}
In ogni evento si generano 1-2 K*, il cui decadimento è elaborato in fase di generazione.
Da una K* si possono ottenere o una coppia Pione+/Kaone- o Pione-/Kaone+, ciascuna con probabilità del 50\%.


\section{Analisi}
%Discutere la congruenza delle distribuzioni osservate con i dati in input
%alla generazione, spiegare brevemente l’approccio seguito per estrarre il segnale
%della risonanza
Riportiamo le tabelle delle occorrenze dei tipi di particelle, distribuzione di generazione dei parametri cinematici e segnale della K*.

\begin{table}[H]
  \begin{center}
    \caption{Abbondanza delle particelle.}
    \label{tab:table1}
    \begin{tabular}{c|c|c} % 
      \textbf{Specie} & 
      \textbf{Occorrenze osservate ($10^3$)} & 
      \textbf{occorrenze attese ($10^3$)}\\
      
      \hline
      $\pi$+ & 4000 $\pm$ 2 & 4000\\
      $\pi$- & 4000 $\pm$ 2 & 4000\\
      K+ 	 & 500.0 $\pm$ 0.7 & 500\\
      K- 	 & 500.0 $\pm$ 0.7 & 500\\
      P+ 	 & 450.0 $\pm$ 0.7  & 450\\
      P- 	 & 450.0 $\pm$ 0.7 & 450\\
      K* 	 & 100.0 $\pm$ 0.3 & 100\\
     

    \end{tabular}
  \end{center}
\end{table}

\begin{table}[H]
  \begin{center}
    \caption{Distribuzione angoli polari e azimutali, modulo dell'impulso.}
    \label{tab:table2}
    \begin{tabular}{c|c|c|c|c} % 
      \textbf{Distribuzione} & \textbf{parametri del fit} & \textbf{$\chi$} & \textbf{DOF} & \textbf{$\chi$/DOF}\\
      \hline
      Angolo polare & 0.3183 $\pm$ 0.0001 & 102.69 & 99 & 1.04\\
      Angolo azimutale & 0.1592 $\pm$ 0.0001 & 92.88 & 99 & 0.94 \\
      Impulso & -1.0003 $\pm$ 0.0003 & 125.42 & 98 & 1.28\\
    \end{tabular}
  \end{center}
\end{table}

I valori osservati nelle tabelle \ref{tab:table1} e \ref{tab:table2} sono compatibili con i parametri del generatore di particelle.
I valori di angolo polare e azimutale sono stati adattati ad una distribuzione normalizzata, al contrario di quella prodotta dal programma di generazione.

\begin{table}[H]
  \begin{center}
    \caption{Analisi della K*.}
    \label{tab:table3}
    \begin{tabular}{c|c|c|c|c} % 
      \textbf{Distribuzione e fit} & 
      \textbf{Media ($\frac{GeV}{c^2}$)} & 
      \textbf{$\sigma$ ($\frac{GeV}{c^2}$)} & 
      \textbf{Ampiezza ($10^4$)} & 
      \textbf{$\chi^2$/DOF}\\
      
      \hline
      Coppie $\pi$/K  & 0.886 $\pm$ 0.003 &0.051 $\pm$ 0.003  & 8.0 $\pm$ 0.4 & 1.03\\
      Discordi-Concordi & 0.892 $\pm$ 0.004 & 0.042 $\pm$ 0.004 & 9.0 $\pm$ 0.7 & 0.99\\
      Benchmark & 0.8918 $\pm$ 0.0002 & 0.0500 $\pm$ 0.0001 & 8.00 $\pm$ 0.03  &  1.23\\
    \end{tabular}
  \end{center}
\end{table}

\subsection{Estrazione del segnale di risonanza}
Per estrarre il segnale di risonanza, abbiamo sfruttato il fatto che il decadimento della K* introduce delle particelle in coppie Pione-Kaone con carica discorde. 

Ci aspettiamo che queste contribuiscano agli istogrammi di massa invariante di \textit{carica discorde} e \textit{coppie Pione-Kaone discordi}.

Al contrario, nei rispettivi istogrammi di carica concorde, ci aspettiamo di osservare solo fondo.

Sottraendo rispettivamente gli istogrammi, i segnali di fondo si elidono e resta il segnale della K*.
Un fit gaussiano consente di estrarre la distribuzione di massa invariante caratteristica della K* e determinarne massa (media della gaussiana) e larghezza di risonanza (deviazione standard).

\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{images/DistributionsCanvas.png}

\label{fig:fig1}
\caption{Distribuzioni di angolo polare, angolo azimutale, modulo dell'impulso e tipo di particella}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{images/SignalCanvas.png}

\label{fig:fig2}
\caption{Distribuzione delle masse invarianti.}
\end{figure}

In figura \ref{fig:fig2} sono riportate le distribuzioni di massa invariante. A sinistra, ottenute per sottrazione degli istogrammi di massa invariante Pioni-Kaoni \textit{discorde-concorde}. Al centro, ottenuti per sottrazione degli istogrammi di massa invariante tra tutte le particelle di carica \textit{discorde-concorde}. A destra, le masse invarianti ottenute a partire dalle particelle figlie di una stessa K*.

\subsection{Consistenza delle distribuzioni}
Le distribuzioni dei parametri cinematici e del tipo di particella (figura \ref{fig:fig1}) sono consistenti con le impostazioni del generatore.


\section{Appendice}

Riportiamo il codice del programma.

\subsection{Programma di generazione}

\paragraph{main.cpp}

\begin{verbatim}
#include "Definitions.hpp"

#include "TApplication.h"
#include "TDirectory.h"
#include <TH1.h>
#include "TFile.h"

#include "generator/ParticleGenerator.hpp"
#include "particleStorage.hpp"
#include "particles/ParticleType.hpp"

int main(int argc, char **argv) {
    // object ownership setup
    #ifdef PROGRAM_USE_LOCAL_OWNERSHIP
        TDirectory::AddDirectory(kFALSE);
        TH1::AddDirectory(kFALSE);
    #endif

    //allocate memory for particle data
    ResonanceSimulator::ParticleGenerator::loadParticles();

    //create generator object
    ResonanceSimulator::ParticleGenerator generator{};
    // run the simulation
    // save result in unique pointer
    std::unique_ptr<ResonanceSimulator::particleStorage> result{generator(1e5)};

    //write to file
    std::unique_ptr<TFile> output_file{new TFile("Particle.root", "RECREATE")};
    result->Write();
    output_file->Close();

    return 0;
}
\end{verbatim}

\paragraph{ParticleType.hpp}

\begin{verbatim}
#ifndef PARTICLETYPE_HPP
#define PARTICLETYPE_HPP

#include <string>

namespace ResonanceSimulator {

    class ParticleType {

    public:
        enum Type { /// particle type enum
            P_Pion, N_Pion, P_Kaon, N_Kaon, P_Prot, N_Prot, R_Kaon
        };
        enum DecaymentType { /// decay result type enum
            P1,//P+ K-
            P2 //P- K+
        };

        ParticleType(int name, double mass, int charge);

        virtual ~ParticleType() = default;

        virtual void Print() const;

        [[nodiscard]] int GetName() const;

        [[nodiscard]] double GetMass() const;

        [[nodiscard]] int GetCharge() const;

        [[nodiscard]] virtual double GetWidth() const;

    private:
        const Type fName; ///name of the particle, expressed as an enum constant
        const double fMass;
        const int fCharge;
    };
}

#endif


\end{verbatim}

\paragraph{ParticleType.cpp}

\begin{verbatim}
#include "particles/ParticleType.hpp"
#include <iostream>

namespace ResonanceSimulator {

    ParticleType::ParticleType(int name, double mass, int charge) :
            fName((Type) name),
            fMass(mass),
            fCharge(charge) {}

    void ParticleType::Print() const {
        std::cout << "Name: " << fName << '\n'
                  << "Mass: " << fMass << '\n'
                  << "Charge: " << fCharge << '\n';
    }

    int ParticleType::GetName() const {
        return fName;
    }

    double ParticleType::GetMass() const {
        return fMass;
    }

    int ParticleType::GetCharge() const {
        return fCharge;
    }

    double ParticleType::GetWidth() const {
        return 0;
    }
}
\end{verbatim}

\paragraph{ResonanceType.hpp}

\begin{verbatim}
#ifndef RESONANCETYPE_HPP
#define RESONANCETYPE_HPP

#include "particles/ParticleType.hpp"

namespace ResonanceSimulator {
    class ResonanceType : public ParticleType {

    public:
        ResonanceType(int name, double mass, int charge, double width);

        [[nodiscard]] double GetWidth() const override;

        void Print() const override;

    private:
        double fWidth;
    };
}

#endif
\end{verbatim}

\paragraph{ResonanceType.cpp}
\begin{verbatim}
#include "particles/ResonanceType.hpp"

#include <iostream>

namespace ResonanceSimulator {

    ResonanceType::ResonanceType(const int name, double mass, int charge, double width) :
            ParticleType{name, mass, charge},
            fWidth{width} {

    }

    double ResonanceType::GetWidth() const {
        return fWidth;
    }

    void ResonanceType::Print() const {
        ParticleType::Print();
        std::cout << "Resonance: " << fWidth << '\n';
    }
}
\end{verbatim}

\paragraph{Particle.hpp}
\begin{verbatim}
//
// Created by Giacomo Errani on 25/10/23.
//

#ifndef PARTICLE_HPP
#define PARTICLE_HPP

#include "particles/ParticleType.hpp"
#include "particles/ResonanceType.hpp"

#include <memory>
#include <vector>
#include <string>


namespace ResonanceSimulator {
    class Particle {
        using pTypeStorage = std::vector<std::unique_ptr<ParticleType>>;
    public:
        explicit Particle(int name, double Px = 0, double Py = 0, double Pz = 0);

        [[nodiscard]] int GetParticleName() const;

        static void AddParticleType(int name, double mass, int charge, double width = 0);

        static void PrintParticleList();

        void SetParticleType(int name);

        void PrintData() const;

        void SetP(double px, double py, double pz);

        [[nodiscard]] double GetPx() const;

        [[nodiscard]] double GetPy() const;

        [[nodiscard]] double GetPz() const;

        [[nodiscard]] int GetCharge() const;

        [[nodiscard]] double GetMass() const;

        [[nodiscard]] double GetEnergy() const;

        [[nodiscard]] double InvMass(Particle const &p) const;

        int Decay2body(Particle &dau1, Particle &dau2) const;

    private:
        void Boost(double bx, double by, double bz);

        static pTypeStorage fParticleType;
        static constexpr int fMaxNumParticleType{10};

        int fParticleName;
        double fPx;
        double fPy;
        double fPz;

    };
}

#endif

\end{verbatim}

\paragraph{Particle.cpp}
\begin{verbatim}
#include "particles/Particle.hpp"

#include <algorithm>
#include <iostream>
#include <numeric>
#include <cmath>
#include <cstdlib>

#include "TMath.h"

namespace ResonanceSimulator {

    Particle::Particle(const int name, double Px, double Py, double Pz) :
            fParticleName{name},
            fPx{Px},
            fPy{Py},
            fPz{Pz} {
        //check that the requested particle name exist
        fParticleType.at(name);
    }

    int Particle::GetParticleName() const {
        return fParticleName;
    }

    void Particle::AddParticleType(int name, double mass, int charge, double width) {
        if (fParticleType.size() == fMaxNumParticleType) {
            throw std::runtime_error{"Maximum particle number reached!"};
        }
        //fParticleType.at(name); //se non c'è, inserisci
        if (width == 0) { //may cause troubles with FP numbers
            fParticleType[name] = std::make_unique<ParticleType>(name, mass, charge);
        } else {
            fParticleType[name] = std::make_unique<ResonanceType>(name, mass, charge, width);
        }
    }

    void Particle::SetParticleType(int name) {
        fParticleType.at(name);
        fParticleName = name;
    }

    void Particle::PrintParticleList() {
        std::for_each(fParticleType.cbegin(), fParticleType.cend(), [](auto const &node) {
            node->Print();
        });
    }

    void Particle::PrintData() const {
        std::cout << "Name:" << fParticleName << '\n'
                  << "PX" << fPx << '\n'
                  << "PY" << fPy << '\n'
                  << "PZ" << fPz << '\n';
    }

    void Particle::SetP(double px, double py, double pz) {
        fPx = px;
        fPy = py;
        fPz = pz;
    }

    double Particle::GetPx() const {
        return fPx;
    }

    double Particle::GetPy() const {
        return fPy;
    }

    double Particle::GetPz() const {
        return fPz;
    }

    double Particle::InvMass(const Particle &p) const {
        auto e{GetEnergy() + p.GetEnergy()};

        auto x = fPx + p.GetPx();
        auto y = fPy + p.GetPy();
        auto z = fPz + p.GetPz();

        return TMath::Sqrt(e * e - (x * x + y * y + z * z));

    }

    [[nodiscard]] double Particle::GetMass() const {
        return fParticleType.at(fParticleName)->GetMass();
    }

    double Particle::GetEnergy() const {
        return TMath::Sqrt(TMath::Power(GetMass(), 2) +
                           TMath::Power(fPx, 2) +
                           TMath::Power(fPy, 2) +
                           TMath::Power(fPz, 2));
    }

    //initialise map
    Particle::pTypeStorage Particle::fParticleType(120);

    int Particle::Decay2body(Particle &dau1, Particle &dau2) const {
        if (GetMass() == 0.0) {
            std::cout << "there is no decay if mass is zero";
            return 1;
        }

        double massMot = GetMass();
        double massDau1 = dau1.GetMass();
        double massDau2 = dau2.GetMass();

        double x1, x2, w, y1;

        double invnum = 1. / RAND_MAX;
        do {
            x1 = 2.0 * rand() * invnum - 1.0;
            x2 = 2.0 * rand() * invnum - 1.0;
            w = x1 * x1 + x2 * x2;
        } while (w >= 1.0);

        w = sqrt((-2.0 * log(w)) / w);
        y1 = x1 * w;

        massMot += fParticleType[fParticleName]->GetWidth() * y1;

        if (massMot < massDau1 + massDau2) {
            std::cout << "Decayment cannot be preformed because mass is too low in this channel\n";
            return 2;
        }

        double pout = sqrt((massMot * massMot - (massDau1 + massDau2) * (massDau1 + massDau2)) *
                           (massMot * massMot - (massDau1 - massDau2) * (massDau1 - massDau2))) / massMot * 0.5;

        double norm = 2 * M_PI / RAND_MAX;

        double phi = rand() * norm;
        double theta = rand() * norm * 0.5 - M_PI / 2.;
        dau1.SetP(pout * sin(theta) * cos(phi), pout * sin(theta) * sin(phi), pout * cos(theta));
        dau2.SetP(-pout * sin(theta) * cos(phi), -pout * sin(theta) * sin(phi), -pout * cos(theta));

        double energy = sqrt(fPx * fPx + fPy * fPy + fPz * fPz + massMot * massMot);

        double bx = fPx / energy;
        double by = fPy / energy;
        double bz = fPz / energy;

        dau1.Boost(bx, by, bz);
        dau2.Boost(bx, by, bz);

        return 0;
    }


    void Particle::Boost(double bx, double by, double bz) {
        double energy = GetEnergy();

        //Boost this Lorentz vector
        double b2 = bx * bx + by * by + bz * bz;
        double gamma = 1.0 / sqrt(1.0 - b2);
        double bp = bx * fPx + by * fPy + bz * fPz;
        double gamma2 = b2 > 0 ? (gamma - 1.0) / b2 : 0.0;

        fPx += gamma2 * bp * bx + gamma * bx * energy;
        fPy += gamma2 * bp * by + gamma * by * energy;
        fPz += gamma2 * bp * bz + gamma * bz * energy;
    }

    int Particle::GetCharge() const {
        return fParticleType[fParticleName]->GetCharge();
    }

}
\end{verbatim}


\paragraph{ProportionGenerator.hpp}
Questa classe è un template, quindi interamente definita nell'header.

\begin{verbatim}
#ifndef PROPORTIONGENERATOR_HPP
#define PROPORTIONGENERATOR_HPP

#include "particles/ParticleType.hpp"
#include <map>
#include <vector>
#include <iostream>
#include <numeric>

#include "TRandom.h"

namespace ResonanceSimulator {

/**
 * This class generates, based on definite proportions, the elements it is instructed to
 * @tparam GEN The type of the object to be generated
 *
 * NOTE: probability is given in percentile in integer values (to avoid FP problems)
 */
    template<typename GEN>
    class ProportionGenerator {
        /**
         * Struct representing a node of generation, holding values with cumulative weight
         */
        struct Node {
            GEN fValue{}; /// Value
            float fCumulativeProbability{}; /// Relevant cumulative probability
        };
        /**
         * Construct the generator
         * @param sourceData Map associating values to be generated to relevant probability values
         */
    public:
        using probType = float;/// type to represent probability

        explicit ProportionGenerator(std::map<GEN, probType> sourceData) :
                fNodes{} {
            //check probability
            auto totalProb = std::accumulate(sourceData.begin(),
                                             sourceData.end(),
                                             0, [](auto const &acc, auto const &node) {
                        return acc + node.second; //sum probabilities
                    });

            if (std::abs(totalProb - 100) < 0.01) { //FP epsilon
                throw std::runtime_error{"Sum of probability is not 100!"};
            }

            //allocate space for the nodes
            fNodes.reserve(sourceData.size());
            //fill f nodes
            probType accumulator{0}; //hold accumulate probability
            for (auto const &node: sourceData) {
                accumulator += node.second; //accumulate probabilities
                fNodes.push_back({node.first, accumulator});
            }
        }

        /**
         * Generate function
         * @return A randomly generated value, based on the input data
         */
        GEN operator()() {
            //genrate value, cast to int
            probType y{static_cast<probType>(gRandom->Rndm())};

            for (auto const &node: fNodes) {
                //if the value generated is less than, i am generated
                if (y < node.fCumulativeProbability) {
                    return node.fValue; //end cycle
                }
            }
            throw std::runtime_error{"Cannot generate!"};
        }

    private:
        std::vector<Node> fNodes;


    };

}


#endif


\end{verbatim}

\paragraph{•}



\end{document}